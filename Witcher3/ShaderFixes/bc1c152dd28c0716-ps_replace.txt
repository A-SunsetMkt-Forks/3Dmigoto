Texture2D<float4> t0 : register(t0);

cbuffer cb3 : register(b3)
{
  float4 cb3[2];
}


Texture2D<float4> StereoParams : register(t125);
Texture1D<float4> IniParams : register(t120);

void main(
  float4 v0 : SV_Position0,
  out float4 o0 : SV_Target0)
{
  float4 r0,r1,r2;
  uint4 bitmask, uiDest;
  float4 fDest;

  r0.xy = (int2)v0.xy;
  r0.zw = (int2)cb3[0].zw;
  r1.x = (uint)r0.w << 1;
  r1.x = (int)r0.z + (int)r1.x;
  r1.yz = (int2)r0.xy ^ (int2)r1.xx;
  r2.xy = max(-r0.xy, r0.xy);
  r1.w = max(-r1.x, r1.x);
  uiDest.xy = (uint2)r2.xy / (uint2)r1.ww;
  r2.xy = uiDest.xy;
  r2.zw = -(int2)r2.xy;
  r1.yz = (int2)r1.yz & int2(0,0);
  r1.yz = r1.yz ? r2.zw : r2.xy;
  r0.xy = mad((int2)-r1.yz, (int2)r1.xx, (int2)r0.xy);
  r1.xw = (int)r0.xy >= (int)r0.ww;
  r1.x = r1.w ? r1.x : 0;
  r1.w = (int)r0.z + (int)r0.w;
  r2.xy = (int)r0.xy < (int)r1.ww;
  r1.x = r1.x ? r2.x : 0;
  r1.x = r2.y ? r1.x : 0;
  if (r1.x != 0) {
    r0.xy = (int2)-r0.ww + (int2)r0.xy;
    r2.xyz = (int3)cb3[1].yzx;
    r0.w = (uint)r2.x << 1;
    r0.z = (int)r0.w + (int)r0.z;
    r0.zw = mad((int2)r1.yz, (int2)r0.zz, (int2)r0.xy);
    r1.xy = (int2)r2.yy + (int2)r0.zw;
    r1.zw = r2.zz;
    r1.xyz = t0.Load(r1.xyz).xyz;
    r0.xy = r0.xy;
    r0.xy = float2(5.000000e-001,5.000000e-001) + r0.xy;
    r0.z = trunc(cb3[0].z);
    r0.xy = r0.xy / r0.zz;
    r0.xy = r0.xy * float2(2.000000e+000,2.000000e+000) + float2(-1.000000e+000,-1.000000e+000);
    r0.x = dot(r0.xy, r0.xy);
    r0.x = 1.000000000e+000 >= r0.x;
    r0.x = r0.x ? 1.000000 : 0;
    r0.xyz = r1.xyz * r0.xxx;
  } else {
    r0.xyz = float3(0.000000e+000,0.000000e+000,0.000000e+000);
  }
  o0.xyz = r0.xyz;
  o0.w = 1.000000000e+000;
  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Original ASM ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) D3D Shader Disassembler
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Position              0   xyzw        0      POS   float   xy  
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb3[2], immediateIndexed
dcl_resource_texture2d (float,float,float,float) t0
dcl_input_ps_siv linear noperspective v0.xy, position
dcl_output o0.xyzw
dcl_temps 3
ftoi r0.xy, v0.xyxx
ftoi r0.zw, cb3[0].zzzw
ishl r1.x, r0.w, l(1)
iadd r1.x, r0.z, r1.x
xor r1.yz, r0.xxyx, r1.xxxx
imax r2.xy, r0.xyxx, -r0.xyxx
imax r1.w, r1.x, -r1.x
udiv r2.xy, null, r2.xyxx, r1.wwww
ineg r2.zw, r2.xxxy
and r1.yz, r1.yyzy, l(0, 0x80000000, 0x80000000, 0)
movc r1.yz, r1.yyzy, r2.zzwz, r2.xxyx
imad r0.xy, -r1.yzyy, r1.xxxx, r0.xyxx
ige r1.xw, r0.xxxy, r0.wwww
and r1.x, r1.w, r1.x
iadd r1.w, r0.z, r0.w
ilt r2.xy, r0.xyxx, r1.wwww
and r1.x, r1.x, r2.x
and r1.x, r2.y, r1.x
if_nz r1.x
  iadd r0.xy, -r0.wwww, r0.xyxx
  ftoi r2.xyz, cb3[1].yzxy
  ishl r0.w, r2.x, l(1)
  iadd r0.z, r0.w, r0.z
  imad r0.zw, r1.yyyz, r0.zzzz, r0.xxxy
  iadd r1.xy, r2.yyyy, r0.zwzz
  mov r1.zw, r2.zzzz
  ld_indexable(texture2d)(float,float,float,float) r1.xyz, r1.xyzw, t0.xyzw
  itof r0.xy, r0.xyxx
  add r0.xy, r0.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000)
  round_z r0.z, cb3[0].z
  div r0.xy, r0.xyxx, r0.zzzz
  mad r0.xy, r0.xyxx, l(2.000000, 2.000000, 0.000000, 0.000000), l(-1.000000, -1.000000, 0.000000, 0.000000)
  dp2 r0.x, r0.xyxx, r0.xyxx
  ge r0.x, l(1.000000), r0.x
  and r0.x, r0.x, l(0x3f800000)
  mul r0.xyz, r0.xxxx, r1.xyzx
else 
  mov r0.xyz, l(0,0,0,0)
endif 
mov o0.xyz, r0.xyzx
mov o0.w, l(1.000000)
ret 
// Approximately 0 instruction slots used

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Recompiled ASM ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.30.9200.20789
//
//
// Buffer Definitions: 
//
// cbuffer cb3
// {
//
//   float4 cb3[2];                     // Offset:    0 Size:    32
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// t0                                texture  float4          2d    0        1
// cb3                               cbuffer      NA          NA    3        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Position              0   xyzw        0      POS   float   xy  
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb3[2], immediateIndexed
dcl_resource_texture2d (float,float,float,float) t0
dcl_input_ps_siv linear noperspective v0.xy, position
dcl_output o0.xyzw
dcl_temps 3
round_z r0.xy, v0.xyxx
round_z r0.zw, cb3[0].zzzw
ftou r1.x, r0.w
ishl r1.x, r1.x, l(1)
utof r1.x, r1.x
ftoi r1.yz, r0.zzwz
ftoi r0.z, r1.x
iadd r0.z, r0.z, r1.y
itof r1.x, r0.z
ftou r2.xy, |r0.xyxx|
ftou r1.x, |r1.x|
udiv r1.xw, null, r2.xxxy, r1.xxxx
utof r1.xw, r1.xxxw
ftoi r2.xy, -r1.xwxx
ftoi r0.xy, r0.xyxx
imad r0.xy, r2.xyxx, r0.zzzz, r0.xyxx
ige r0.z, r0.x, r1.z
iadd r1.z, r1.z, r1.y
ilt r1.z, r0.x, r1.z
and r0.z, r0.z, r1.z
if_nz r0.z
  ftoi r0.z, -r0.w
  iadd r0.xy, r0.xyxx, r0.zzzz
  itof r0.zw, r0.xxxy
  round_z r2.xyz, cb3[1].yzxy
  ftou r1.z, r2.x
  ishl r1.z, r1.z, l(1)
  utof r1.z, r1.z
  ftoi r1.z, r1.z
  iadd r1.y, r1.y, r1.z
  ftoi r1.xz, r1.xxwx
  imad r0.xy, r1.xzxx, r1.yyyy, r0.xyxx
  ftoi r1.xzw, r2.yyzz
  iadd r1.xy, r0.xyxx, r1.xxxx
  ld_indexable(texture2d)(float,float,float,float) r1.xyz, r1.xyzw, t0.xyzw
  add r0.xy, r0.zwzz, l(0.500000, 0.500000, 0.000000, 0.000000)
  round_z r0.z, cb3[0].z
  div r0.xy, r0.xyxx, r0.zzzz
  mad r0.xy, r0.xyxx, l(2.000000, 2.000000, 0.000000, 0.000000), l(-1.000000, -1.000000, 0.000000, 0.000000)
  dp2 r0.x, r0.xyxx, r0.xyxx
  ge r0.x, l(1.000000), r0.x
  and r0.x, r0.x, l(0x3f800000)
  mul r0.xyz, r0.xxxx, r1.xyzx
else 
  mov r0.xyz, l(0,0,0,0)
endif 
mov o0.xyz, r0.xyzx
mov o0.w, l(1.000000)
ret 
// Approximately 49 instruction slots used

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
